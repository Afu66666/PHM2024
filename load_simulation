import numpy as np
import torch
from tqdm import tqdm  # 添加进度条以便监控

def simulate_different_loads(signal, original_load=-1, target_load=None):
    """
    模拟不同负载条件下的信号特性
    
    参数:
        signal: 原始信号，形状为 [timesteps, features] 或 [samples, timesteps, features]
        original_load: 原始信号的负载条件
        target_load: 目标负载条件，如果为None则随机选择
        
    返回:
        模拟后的信号
    """
    is_batch = len(signal.shape) == 3
    
    # 如果目标负载未指定，随机选择
    if target_load is None:
        target_load = np.random.choice([0, 1])  # 随机选择0kN或1kN
    
    # 从-1kN模拟到0kN或1kN
    if is_batch:
        samples, timesteps, features = signal.shape
        # 创建一个新数组而不是修改输入
        result = np.zeros_like(signal, dtype=np.float64)
        
        for i in range(samples):
            # 逐样本处理
            if target_load == 0:  # 模拟0kN
                # 0kN通常振动较弱，因此减弱某些频率成分
                amplitude_factor = 1.0 - 0.15 * np.random.rand()  # 减弱幅度
                result[i] = signal[i] * amplitude_factor
                
                # 在频域中进行调整 - 仅对较大样本应用FFT
                if timesteps > 1000:  # 只对较大信号执行频域变换
                    for j in range(features):
                        # 对每个特征进行频域变换
                        fft = np.fft.rfft(signal[i, :, j])
                        
                        # 生成频域调整因子 - 0kN负载下高频衰减更明显
                        freq_bins = fft.shape[0]
                        freq_factors = np.linspace(1.0, 0.7, freq_bins)  # 高频更衰减
                        freq_factors = freq_factors * (0.9 + 0.2 * np.random.rand(freq_bins))
                        
                        # 相位调整
                        phases = np.exp(1j * np.random.normal(0, 0.2, fft.shape))
                        
                        # 应用调整
                        fft_shifted = fft * freq_factors * phases
                        
                        # 逆变换回时域
                        result[i, :, j] = np.fft.irfft(fft_shifted, timesteps)
                    
            elif target_load == 1:  # 模拟1kN
                # 1kN通常振动较强，因此增强某些频率成分
                amplitude_factor = 1.0 + 0.25 * np.random.rand()  # 增强幅度
                result[i] = signal[i] * amplitude_factor
                
                # 在频域中进行调整 - 仅对较大样本应用FFT
                if timesteps > 1000:  # 只对较大信号执行频域变换
                    for j in range(features):
                        # 对每个特征进行频域变换
                        fft = np.fft.rfft(signal[i, :, j])
                        
                        # 生成频域调整因子 - 1kN负载下中频增强更明显
                        freq_bins = fft.shape[0]
                        mid_point = freq_bins // 2
                        freq_factors = np.ones(freq_bins)
                        freq_factors[mid_point-mid_point//2:mid_point+mid_point//2] = 1.3  # 中频增强
                        freq_factors = freq_factors * (0.9 + 0.2 * np.random.rand(freq_bins))
                        
                        # 相位调整，1kN负载下相位变化更大
                        phases = np.exp(1j * np.random.normal(0, 0.3, fft.shape))
                        
                        # 应用调整
                        fft_shifted = fft * freq_factors * phases
                        
                        # 逆变换回时域
                        result[i, :, j] = np.fft.irfft(fft_shifted, timesteps)
    else:
        # 处理单个样本 (这种情况在批处理中可能不会用到)
        timesteps, features = signal.shape
        result = np.zeros_like(signal, dtype=np.float64)
        
        if target_load == 0:  # 模拟0kN
            amplitude_factor = 1.0 - 0.15 * np.random.rand()
            result = signal * amplitude_factor
            
            # 在频域中调整
            for j in range(features):
                fft = np.fft.rfft(signal[:, j])
                freq_bins = fft.shape[0]
                freq_factors = np.linspace(1.0, 0.7, freq_bins)
                freq_factors = freq_factors * (0.9 + 0.2 * np.random.rand(freq_bins))
                phases = np.exp(1j * np.random.normal(0, 0.2, fft.shape))
                fft_shifted = fft * freq_factors * phases
                result[:, j] = np.fft.irfft(fft_shifted, timesteps)
                
        elif target_load == 1:  # 模拟1kN
            amplitude_factor = 1.0 + 0.25 * np.random.rand()
            result = signal * amplitude_factor
            
            # 在频域中调整
            for j in range(features):
                fft = np.fft.rfft(signal[:, j])
                freq_bins = fft.shape[0]
                mid_point = freq_bins // 2
                freq_factors = np.ones(freq_bins)
                freq_factors[mid_point-mid_point//2:mid_point+mid_point//2] = 1.3
                freq_factors = freq_factors * (0.9 + 0.2 * np.random.rand(freq_bins))
                phases = np.exp(1j * np.random.normal(0, 0.3, fft.shape))
                fft_shifted = fft * freq_factors * phases
                result[:, j] = np.fft.irfft(fft_shifted, timesteps)
    
    return result

def augment_with_load_simulation(component_data_list, conditions, labels, num_augmented=2, batch_size=4):
    """
    使用负载模拟增强数据集，优化版本
    
    参数:
        component_data_list: 各部件原始时域数据字典
        conditions: 工况条件数组 [samples, 2]
        labels: 标签数组
        num_augmented: 每个样本生成的增强样本数量
        batch_size: 批处理大小，处理速度和内存使用的平衡
        
    返回:
        增强后的数据字典、工况和标签
    """
    # 确保输入是numpy数组
    if isinstance(labels, torch.Tensor):
        labels = labels.numpy()
    
    if isinstance(conditions, torch.Tensor):
        conditions = conditions.numpy()
    
    # 确保conditions是可写的
    conditions = conditions.copy()
    
    # 原始样本数量
    original_samples = len(labels)
    
    # 初始化增强后的数据 - 确保创建新数组而非视图
    augmented_components = {}
    for component, data in component_data_list.items():
        # 使用copy()确保创建新数组
        augmented_components[component] = data.copy()
    
    augmented_conditions = conditions.copy()
    augmented_labels = labels.copy()
    
    print(f"原始样本数: {original_samples}")
    print(f"开始负载模拟数据增强，每个样本将生成 {num_augmented} 个增强版本...")
    
    # 使用批处理以提高效率，避免逐样本处理
    for target_load in [0, 1]:  # 对每种目标负载
        print(f"处理负载 {target_load}kN...")
        
        # 每种负载生成num_augmented/2个样本
        samples_per_load = num_augmented // 2
        
        for sample_idx in tqdm(range(samples_per_load)):  # 每种负载生成多个变体
            # 使用批处理来提高速度
            for batch_start in range(0, original_samples, batch_size):
                batch_end = min(batch_start + batch_size, original_samples)
                batch_size_actual = batch_end - batch_start
                
                # 为当前批次中的每个部件创建增强样本
                new_components = {}
                for component, data in component_data_list.items():
                    # 获取当前批次样本
                    batch_samples = data[batch_start:batch_end]
                    
                    # 模拟不同负载
                    augmented_samples = simulate_different_loads(
                        batch_samples,
                        original_load=-1,  # 训练集是-1kN
                        target_load=target_load
                    )
                    
                    # 将结果存入临时字典
                    new_components[component] = augmented_samples
                
                # 创建新的工况标签批次
                new_conditions = conditions[batch_start:batch_end].copy()
                # 修改负载值，保持频率不变
                new_conditions[:, 1] = target_load
                
                # 获取标签批次
                new_labels = labels[batch_start:batch_end].copy()
                
                # 添加到增强数据集
                for component, data in new_components.items():
                    # 安全连接数组，避免修改只读数组
                    augmented_components[component] = np.concatenate(
                        [augmented_components[component], data], axis=0
                    )
                
                augmented_conditions = np.concatenate([augmented_conditions, new_conditions], axis=0)
                augmented_labels = np.concatenate([augmented_labels, new_labels], axis=0)
    
    # 打印增强后的统计信息
    print(f"增强后样本总数: {len(augmented_labels)}")
    print(f"原始负载分布: {np.unique(conditions[:, 1], return_counts=True)}")
    print(f"增强后负载分布: {np.unique(augmented_conditions[:, 1], return_counts=True)}")
    
    return augmented_components, augmented_conditions, augmented_labels
